openapi: 3.1.0
info:
  title: DOCUMENTATION API SPI
  x-redocly-registry: orgsk_+5fHjITDPWE9xQTrVNvxXoIMweI=_h8aU/5LVvnxQePkxawisYEdwYzf10zWWNLvtJE59h9E=
  description: |-

    # Généralités
    PI-SPI gère les opérations de virement, de paiement, de règlement et de gestion des comptes des participants.

    L'API-SPI suit les principes fondamentaux d'une `API REST`, mais diffère d'une `API REST` classique dans le traitement de la demande du client. Chaque appel à l'API génère un message `(mis sur une file d'attente de messages)` et retourne en réponse l'identifiant du message créé dans l’entête `Location` et la date de réception du message dans l’entête `Date` à l’exception de l’opération de vérification du statut d’un virement effectuée à l’expiration du transfert.

    La communication entre un participant et le système SPI se fait à travers des appels d’API à l'aide de requêtes `HTTP`. Toutes les communications doivent être sécurisées en utilisant `HTTPs (HTTP sur TLS8)` tel que décrit dans le document des exigences de sécurité 4 de PI

    <h3><b><u>Remarque</u>:</b></h3> 

    * Les exemples `Java` sont faits avec la `version 17`
    * Les exemples `Javascript` sont faits avec `Node.js`
    * Les exemples `Python` sont faits avec la `version 3.9`

    ## Gestion des versions 

    La stratégie de développement de l'API est de maintenir la rétrocompatibilité entre l'API et ses ressources et services dans la mesure du possible.
    Les APIs de PI utilisent la spécification `SemVer12 (La gestion sémantique de versions)`; en ce sens, les modifications compatibles ne doivent pas générer une nouvelle version majeure.

    La version de l’API utilise ainsi le format` MAJEUR.MINEUR.CORRECTIF`
    * le numéro de version `MAJEUR` quand il y a des changements non rétrocompatibles,
    * le numéro de version `MINEUR` quand il y a des ajouts de fonctionnalités rétrocompatibles,
    * le numéro de version de `CORRECTIF` quand il y a des corrections d’anomalies rétrocompatibles.

    Chaque fois qu'un changement dans ce document définissant les caractéristiques de l'API est mis à jour et affecte d'une manière ou d'une autre un service d'API, une nouvelle version de l’API sera publiée.
    La version initiale de chaque API est `1.0.0`.
    ### `1) Versions de correction `
    L’identifiant de version de correction est  incrémenté si des corrections rétrocompatibles sont introduites. Une correction est définie comme un changement interne qui corrige un comportement incorrect.
    ### `2) Versions mineurs `
    Certaines modifications n'affectent pas la version de la ressource API; par exemple, si l'ordre des paramètres dans une requête change.

    La liste suivante décrit quelques modifications considérées comme rétrocompatibles. Les participants doivent implémenter leur système de manière à ce que les services d'API prennent automatiquement en charge ces modifications sans interrompre le fonctionnement du système:
    * paramètres de requêtes facultatifs
    * ajout de nouveaux codes d'erreur

    Ces types de modifications affectent la version mineure du service d'API.
    ### `3) Versions majeurs`
    La liste suivante décrit les modifications considérées comme rétro-incompatibles si la modification affecte un service d'API connecté à une ressource. Les intégrateurs d'API n'ont pas besoin d'implémenter de manière à prendre automatiquement en charge ces modifications. 
    En effet, pour des changements importants, un plan de migration sera défini et dépendra de la nature de ces changements.
    Les situations suivantes peuvent entraîner la publication d’une version majeure:
    * Paramètres obligatoires supprimés ou ajoutés à une requête
    * Paramètres facultatifs changés en obligatoires dans une requête 
    * Paramètres renommés
    * Types de données modifiés
    * La logique métier d’un service modifiée
    * Les URI de ressource/service d'API modifiées

    Ces types de modifications affectent la version principale du service d'API. Veuillez noter que la liste n'est pas exhaustive ; il peut également y avoir d'autres modifications susceptibles d'affecter la version principale du service d'API. 
    ### `4) Informations de version`
    La gestion des versions s’effectuera via le chemin URI qui consiste à inclure le numéro de version dans le chemin URI et permet de gérer facilement plusieurs versions parallèles de l’API.
    Le numéro de version majeure sera inclus dans l’URL de l’API comme suit: __https://www.example.com/api/v1/products__


    ## Gestion des erreurs 

    En ce qui concerne les réponses notifiant une erreur, PI utilise le format décrit dans la `RFC 7807` qui décrit comment les API peuvent renvoyer des informations d'erreur de manière standardisée.  Une telle réponse contient les éléments suivants :
    <table>
      <tr>
        <td><b>type</b></td>
        <td>Le champ "type" est une URI unique qui identifie le type de problème. L’URI peut être relative.</td>
      </tr>
      <tr>
        <td><b>title</b></td>
        <td>Le champ "title"  fournit une description courte pour comprendre le problème. Il est identique pour le même type de problème.</td>
      </tr>
      <tr>
        <td><b>detail</b></td>
        <td>Le champ "detail" donne des explications sur le problème.</td>
      </tr>
      <tr>
        <td><b>instance</b></td>
        <td>Il indique une référence URI de ressource concernée par le problème. Il est optionnel.</td>
      </tr>
      <tr>
        <td><b>status</b></td>
        <td>Le champ "status" renvoie le code de statut HTTP qui a déclenché cette réponse. Ce champ est optionnel.</td>
      </tr>
    </table>

    Pour donner des informations détaillées sur le problème, des extensions sont permises. Les extensions sont des champs additionnels qui peuvent figurer dans la réponse.

    Ci-dessous un exemple de réponse en JSON et un exemple en XML:
    <img src="./images/exemple-erreur-json.png" />
    <img src="./images/exemple-erreur-xml.png" />

    Ici, le problème `format-invalide` __(identifié par son type URI)__  indique la raison de l’erreur `400` retournée par le serveur lors de la création d’un client; deux extensions sont ajoutées: `typeClient` qui indique le __champ incorrect__, et `invalid-params` qui indiquent les __paramètres invalides et la raison d’invalidité__. 
    Par ailleurs, l'URI de type d'un problème devrait référencer une page HTML expliquant comment résoudre le problème. Cependant des types prédéfinis existent: c’est le cas du type `about:blank` qui indique que __le problème n'a pas de sémantique supplémentaire au-delà de celle du code de statut HTTP__. Lorsque `about:blank` est utilisé, le champ `title` est le même que le libellé du statut HTTP comme montré dans l’exemple suivant:
    <img src="./images/exemple-probleme.png" />

    ## Recommandations 
    __Il est recommandé pour les services API fréquemment utilisés, l'utilisation de connexions persistantes et pour les services API moins fréquemment utilisés, d'utiliser des connexions de courte durée.__

    # Sécurité
    La sécurité des systèmes de paiement est une préoccupation majeure. Les avancées technologiques rapides ont considérablement amélioré les services financiers, mais elles ont également accru les risques de sécurité. Les cyberattaques, les fraudes, les violations de données et les erreurs humaines peuvent avoir des conséquences financières et réputationnelles graves. 

    Pour faire face à ces menaces, plusieurs mesures de sécurité sont mises en place dans la __Plateforme d’Interopérabilité (PI).__

    Le cryptage des échanges avec `TLS` constitue une exigence avec une authentification mutuelle obligatoire lors de l’établissement de la connexion TLS aux APIs de PI.  Pour garantir la non-répudiation, la __signature numérique__ des messages échangés est exigée. 

    Les clés utilisées pour les processus de signature et de cryptage __doivent être certifiées par l’autorité de certification de la PKI__ spécifiquement mise en place pour le système PI.

    ## Authentification
    L'authentification `TLS à deux sens`, également appelée authentification `mutuelle TLS`, repose sur le partage mutuel des certificats publics entre les deux parties (__client__ et __serveur__) et sur la vérification/validation basée sur ces certificats.


    Avec l’authentification mutuelle, l’API de PI présente son certificat `mTLS` au serveur du participant qui l’appelle. Le serveur du participant présente également son certificat client délivré par l'autorité de certification de PI.

    Les étapes générales suivantes décrivent comment une connexion est établie et comment les données sont transférées entre un client et un serveur dans le cas de mTLS :

    * Le client demande une ressource protégée via le protocole HTTPS et le processus de poignée de main SSL/TLS commence.
    * Le serveur renvoie son certificat public au client.
    * Le client vérifie/valide le certificat reçu. Le client vérifie le certificat via l'autorité de certification (CA) pour les certificats signés par une CA.
    * Si le certificat du serveur est validé avec succès, le serveur demande le certificat du client.
    * Le client fournit son certificat public au serveur.
    * Le serveur vérifie/valide le certificat reçu. Le serveur vérifie le certificat via l'autorité de certification pour les certificats signés par une CA.

    Après l'achèvement du processus de poignée de main, le client et le serveur communiquent et transfèrent des données chiffrées avec les clés secrètes partagées entre les deux lors de la poignée de main.
    <img src="./images/cinematique-mtls2.png" />

    `Intégration du MTLS à une réquête`

    __Java__
    ```java
    import java.io.FileInputStream;
    import java.io.IOException;
    import java.net.URI;
    import java.net.http.HttpClient;
    import java.net.http.HttpRequest;
    import java.net.http.HttpResponse.BodyHandlers;
    import java.security.KeyManagementException;
    import java.security.KeyStore;
    import java.security.KeyStoreException;
    import java.security.NoSuchAlgorithmException;
    import java.security.UnrecoverableKeyException;
    import java.security.cert.CertificateException;

    import javax.net.ssl.SSLContext;

    import org.apache.http.ssl.SSLContexts;

    import java.net.http.HttpResponse;

    public class App {

        public static void executeHttpsPostRequest(String url, String requestBody, String keystorePath,String keystorePassword) throws KeyStoreException, NoSuchAlgorithmException, IOException, InterruptedException, URISyntaxException, UnrecoverableKeyException, KeyManagementException, CertificateException {
            // Chargement keystore
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            try (FileInputStream inputStream = new FileInputStream(keystorePath)) {
                keyStore.load(inputStream, keystorePassword.toCharArray());
            }

            // Création SSL context
            SSLContext sslContext = SSLContexts.custom()
                    .loadKeyMaterial(keyStore, keystorePassword.toCharArray())
                    .build();

            HttpClient client = HttpClient.newBuilder()//
                    .sslContext(sslContext) //
                    .version(HttpClient.Version.HTTP_2)
                    .build();

            // Création de la requête POST
            HttpRequest postrequest = HttpRequest.newBuilder()
                    .uri(new URI(url))
                    .headers("Content-Type", "application/xml")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build();

            // Envoi de la requête
            HttpResponse<String> response = client.send(postrequest, BodyHandlers.ofString());
            System.out.println(response.statusCode());
            System.out.println(response.body());
        }

    }
    ````

    __Node.js__
    ```javascript
    const https = require('https');
    const fs = require('fs');
    const tls = require('tls');

    function executeHttpsPostRequest(url,endpoint, postData, options) {
        /**
        * Cette fonction exécute une requête HTTPS POST avec un contexte SSL(MTLS)
        * 
        * @param {string} url - L'URL à laquelle la demande doit être envoyée.
        * @param {string} postData - Les données à envoyer dans le corps de la requête.
        * @param {object} options - Les options à utiliser pour la requête.
        * 
        * @returns {Promise} - Une promise qui se résout avec les données de la réponse ou qui se rejette avec une erreur.
        */
        return new Promise((resolve, reject) => {
            try {
                // Chargement du keystore
                const keystore = fs.readFileSync('path/to/certificate.keystore.pkcs12');

                // Configuration les options du contexte SSL
                const sslContext = tls.createSecureContext({
                    pfx: keystore,
                    passphrase: 'keystore_password'
                });

                // Configuration des options de la requête HTTPS
                const httpsOptions = {
                    hostname: url,
                    port: 443,
                    protocol: 'https:',
                    path: endpoint,
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/xml',
                        'Content-Length': Buffer.byteLength(postData),
                    },
                    cert: keystore,
                    key: keystore,
                    passphrase: 'keystore_password',
                    secureContext: sslContext,
                    rejectUnauthorized: true,
                    requestCert: true,
                    agent: false
                };

                // Envoi de la requête HTTPS
                const req = https.request(httpsOptions, (res) => {
                    let data = '';
                    res.on('data', (chunk) => {
                        data += chunk;
                    });
                    res.on('end', () => {
                        resolve(data);
                    });
                });

                // Traitement des erreurs
                req.on('error', (error) => {
                    reject(error);
                });

                // Envoi des données de la requête
                req.write(postData);
                req.end();
            } catch (error) {
                reject(error);
            }
        });
    }
    ````

    __Python__
    ```python
    import http.client
    import ssl

    def execute_https_post_request(url, endpoint, post_data, cert_file, key_file, headers):
        try:
            # Création d'un contexte SSL personnalisé
            context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)

            # Chargement du certificat client et de la clé privée
            context.load_cert_chain(cert_file, key_file)

            # Connexion au serveur en utilisant le contexte SSL personnalisé
            conn = http.client.HTTPSConnection(url, context=context)

            # Envoi de la requête POST avec MTLS
            conn.request('POST', endpoint, body=post_data, headers=headers)

            # Récupération de la réponse
            return conn.getresponse().read().decode()
            
        except Exception as e:
            print("Erreur survenue: ",e)
            return None
        finally:
            # Fermeture de la connexion
            conn.close()
    ````

    ## Signature numérique
    Afin de garantir l'`intégrité` et la `non-répudiation` des transactions, tous les messages transmis doivent être signés par le participant émetteur. 
    Quelle que soit l'opération effectuée, la réponse au participant est toujours signée par PI.

    ### `1) Signature des messages XML: XMLDsig`

    La norme `XMLDsig` fournit un format standard pour la signature des messages XML, qui peut être utilisé pour garantir l'authenticité et l'intégrité des messages échangés entre différents systèmes.
    XMLDsig permet de signer un message XML en incluant une signature numérique dans le message lui-même. Cette signature numérique est calculée à l'aide d'un algorithme de hachage, qui produit une empreinte numérique du contenu du message. Cette empreinte est ensuite chiffrée à l'aide d'une clé privée, qui peut être vérifiée à l'aide de la clé publique correspondante.

    #### `1.1) Structure de la signature`
    Le tableau suivant explique les différents composants de la signature XML des messages ISO 20022:
    <table>
      <tr>
        <th>Nom / Balise XML</th>
        <th>Cardinalité</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>&lt;Signature&gt;</td>
        <td>[1..1]</td>
        <td>±</td>
        <td>Élément racine de la signature XMLDSig. Définit l'espace de noms, qui pointe vers l’URI du schéma XML à utiliser pour la signature numérique: http://www.w3.org/2000/09/xmldsig#</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&lt;SignedInfo&gt;</td>
        <td>[1..1]</td>
        <td>±</td>
        <td></td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;CanonicalizationMethod&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Spécifie l'algorithme de canonisation à appliquer à l'élément, dans le but de générer la forme canonique du contenu. L'algorithme de canonisation doit être utilisé XMLexclusif: http://www.w3.org/2001/10/xml-exc-c14n#</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;SignatureMethod&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Algorithme utilisé pour générer et valider la signature numérique. La valeur est toujours: http://www.w3.org/2001/04/xmldsig-more#rsa- sha256</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Reference&gt;</td>
        <td>[1..3]</td>
        <td>±</td>
        <td>Permet de spécifier l'algorithme de synthèse (digest) utilisé pour signer l’objet de données, la Chaîne de transformations à appliquer avant de générer le digest.</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URI(Attribut)</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Permet de spécifier les éléments spécifiques référencés</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type(Attribut)</td>
        <td>[0..1]</td>
        <td>Max35Text</td>
        <td>Type d’objet à signer</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Transforms&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Comprend une ou plusieurs balises &lt;Transform&gt;, qui indiquent quelles transformations doivent être appliquées</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algorithm(Attribut)</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Algorithme de transformation utilisé, la valeur est toujours : http://www.w3.org/2001/10/xml-exc-c14n#</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;DigestMethod&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Algorithme de synthèse qui sera appliqué au contenu à signer toujours: http://www.w3.org/2001/04/xmlenc#sha256.</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;DigestValue&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Élément qui contient le résumé (digérer) codé en base64</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&lt;SignatureValue&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Élément qui contient la valeur de la signature encodée en base64</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&lt;KeyInfo&gt;</td>
        <td>[1..1]</td>
        <td>±</td>
        <td>Élément qui contient les données du certificat utilisé pour signer numériquement le contenu. il comprend la balise &lt;X509Data&gt;</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&lt;X509Data&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Élément qui contient les données du certificat X509 utilisé par le signataire. il comprend la balise &lt;X509SubjectName&gt;</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;X509SubjectName&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Élément qui contient les informations sur le propriétaire du certificat</td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;X509Certificate&gt;</td>
        <td>[1..1]</td>
        <td>Max35Text</td>
        <td>Élément qui contient le certificat utilisé pour la signature du message</td>
      </tr>
    </table>
    Pour la signature des message ISO 20022 échangées dans PI, 3 références doivent être calculées :

    * L'élément __Document__ 
    * L’ élément d’entête ( __AppHdr__ ) en excluant les éléments de signature numérique (balise Sgntr)
    * L’ élément __KeyInfo__ qui contient les informations sur le certificat

    La procédure de signature des messages ISO 20022 est décrite de façon détaillée dans le Message User Guide (MUG) du BAH Header 9.

    #### `1.2) Procédure de signature`
    Le processus de création de la signature est indépendant du type de message xml et est décrit dans le diagramme suivant :  
    <img src="./images/procedure-signature.png" />

    ```xml
    Exemple de signature XML:

    <RequestPayload xmlns="urn:bceao:pisfn:xsd:env" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="payload.acmt023.xsd">
    <AppHdr xmlns="urn:iso:std:iso:20022:tech:xsd:head.001.001.03">
        <Fr>
            <FIId>
                <FinInstnId>
                    <Nm>PSP Senegal 001</Nm>
                    <Othr>
                        <Id>SNB001</Id>
                    </Othr>
                </FinInstnId>
            </FIId>
        </Fr>
        <To>
            <FIId>
                <FinInstnId>
                    <Nm>PI</Nm>
                    <Othr>
                        <Id>PIUMOA</Id>
                    </Othr>
                </FinInstnId>
            </FIId>
        </To>
        <BizMsgIdr>MSNB001Wi9C8V3Cxvp0yKZ3HNN3OymzGUvU</BizMsgIdr>
        <MsgDefIdr>acmt.023.001.003</MsgDefIdr>
        <CreDt>2023-04-14T08:08:59.988Z</CreDt>
        <Sgntr>
          <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
            <ds:SignedInfo>
              <ds:CanonicalizationMethod  Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
              <ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
              
              <ds:Reference Type="http://www.w3.org/2000/09/xmldsig#KeyInfo" URI="#KEYINFOIDTOGENERATELATER">
                <ds:Transforms>
                  <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
                </ds:Transforms>
                <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
                <ds:DigestValue>RQnKYAP65A6pZIcqC3i2iz16ycsxegaGe0TY7bT+QXM=</ds:DigestValue>
              </ds:Reference>

              <ds:Reference>
                <ds:Transforms>
                  <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
                </ds:Transforms>
                <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
                <ds:DigestValue>MLPrXt3VpJ0szBcCocxx3NwAq2tELZGHKCZBQs1tOl8=</ds:DigestValue>
              </ds:Reference>

              <ds:Reference URI="">
                <ds:Transforms>
                  <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
                <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/></ds:Transforms>
                <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
                <ds:DigestValue>sWM/pwy9hMBV0mfgS+CeHNFrY3f6fEIzDwenbv4O66A=</ds:DigestValue>
              </ds:Reference>
            </ds:SignedInfo>
            <ds:SignatureValue>UzFiuBAhJKP3MCYkSYkS81apDJuZFyEsvp+3T3s+67fIc+GV7WgKQauHYeOfFruWZS9fC/ZlcxsD&#13;
              0S/Sn9yj0NxDbgZgtFh8oXjAhFFiFunPhh+3X2cG9GK/eshYqYwa5vnjLDbPtKRYhEo+tzG24bD6&#13;
              xuqd7y30W2GN/QuPPGrJZTy2+8m5/OAnIWeGj3A98XBe6y54REE7DC6P+idFWeL0I5oGPqJMoLSn&#13;
              /9f3iJR/fUd3heXaQ8JG35o+WNbhuH1MtHQw+iZiUw88Rl82dOmpNVf1J3hgtJ3kk5gVdHm/fiye&#13;
              NinRo3lauxRT/tS+cFBg3vYm6APELqIg6Wh0Bw==
            </ds:SignatureValue>
            <ds:KeyInfo Id="#KEYINFOIDTOGENERATELATER">
              <ds:X509Data>
                <ds:X509SubjectName>CN=SNB001,O=PSP Senegal 001,C=SN</ds:X509SubjectName>
                <ds:X509Certificate>MIID4jCCAsqgAwIBAgIQPyFUAd1+K015p5OObTRLpDANBgkqhkiG9w0BAQsFADAzMQswCQYDVQQG&#13;
                  EwJTTjEOMAwGA1UECgwFUElTRk4xFDASBgNVBAMMC1BJU0ZOLVNVQkNBMB4XDTIzMDIxNDE3MjU1&#13;
                  M1oXDTI0MDMxNDE4MjU1M1owODELMAkGA1UEBhMCU04xGDAWBgNVBAoTD1BTUCBTZW5lZ2FsIDAw&#13;
                  MTEPMA0GA1UEAxMGU05CMDAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkOGK1JTa&#13;
                  M2Lia5Nj8w+1/yOOTVnop/nQGGHuths0sZhJKsXVo7q8gL3C/XEJC6FUFlo310CkFgTcfRvRSY44&#13;
                  Hne6hzpLfJxUJdC9Vqbn7tC0PO18kdP+ElhQ0Xfe2vuZxZvx1ACaunPiCfdjqTLi46K9ke6DwWLJ&#13;
                  /8+wSaUkMHxCUuP1Fx9DbpGS5NP312rSLwZz/EA8h6BEMdu2AQiBDSOr1wfaJCkMEcjTHY9W35q9&#13;
                  OFqDVQ1VG46+94l4MOYJPWVJ4DodTXhVKHs13VeUl+QSBlUyhTp3luTOXeZC8M479phXjs/im5E6&#13;
                  Qm1Mz9uNHXzDYvrIDfhWJZJ+c/q7NQIDAQABo4HsMIHpMAkGA1UdEwQCMAAwHwYDVR0jBBgwFoAU&#13;
                  deCwA+k/XeaRzxbDxs2c69Vk488wHQYDVR0OBBYEFOlL5YI4FpCAbBtQiFM20xervVyaMA4GA1Ud&#13;
                  DwEB/wQEAwIHgDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDAzB0BgNVHR8EbTBrMGmgZ6BlhmNodHRw&#13;
                  Oi8vcGlzZm4tcGtpLWNhLXN1Yi1jcmwuczMuZXUtd2VzdC0xLmFtYXpvbmF3cy5jb20vY3JsLzE3&#13;
                  MmY4ZDc4LTZkN2YtNGY0OS1iZTk1LTYzNDAyMjg3YjRkYy5jcmwwDQYJKoZIhvcNAQELBQADggEB&#13;
                  AKaNdenv2713vmB3iCRjLwCdvmLIf0R/cjlBxmVO95pys/YnAcK1faCEh3r2rC5uTmZwbQ+vx6Ur&#13;
                  zqTxqK+W8JcM+ynvlQ0zGgXuqDCtQT11UUT7m1ffY/oGLCO/9eWFWlgGnl1fIBurklTqV1/G+iEX&#13;
                  Q8zd29Ai+fur1+7d+IlYmmaNhXUTVBWRTQplMnvjmBKtCnR+iSTyW7FPsSYsbWj/16/OK/9bPjAc&#13;
                  ELLgnnUZCM0CCC8P3KBG9HWDFp4bhEoCvpcnRZvetlJFmEtQ3I0PyLCSQR6v/C0kMjRC4AP9P5kO&#13;
                  NBPik2hTQ9vlbYpa1658foVJtT09L9a8Z6SteoE=
                </ds:X509Certificate>
              </ds:X509Data>
            </ds:KeyInfo>
          </ds:Signature>
        </Sgntr>
      </AppHdr>
      <Document xmlns="urn:iso:std:iso:20022:tech:xsd:acmt.023.001.03">
        <IdVrfctnReq>
          <Assgnmt>
            <MsgId>MSNB001Wi9C8V3Cxvp0yKZ3HNN3OymzGUvU</MsgId>
            <CreDtTm>2023-04-14T08:08:59.982Z</CreDtTm>
            <Assgnr>
              <Agt>
                <FinInstnId>
                  <Nm>PSP Senegal 001</Nm>
                  <Othr>
                    <Id>SNB001</Id>
                  </Othr>
                </FinInstnId>
              </Agt>
            </Assgnr>
            <Assgne>
              <Agt>
                <FinInstnId>
                  <Nm>PSP CI 001</Nm>
                  <Othr>
                    <Id>CIC001</Id>
                  </Othr>
                </FinInstnId>
              </Agt>
            </Assgne>
          </Assgnmt>
          <Vrfctn>
            <Id>ESNB00120230414080859XY02cQYbfcvmyf</Id>
            <PtyAndAcctId>
              <Pty>
                <Nm>Fougnigue</Nm>
                <CtryOfRes>CI</CtryOfRes>
              </Pty>
              <Acct>
                <Id>
                  <Othr>
                    <Id>+221773393882</Id>
                  </Othr>
                </Id>
              </Acct>
            </PtyAndAcctId>
          </Vrfctn>
        </IdVrfctnReq>
      </Document>
    </RequestPayload>
    ```
    #### `1.3) Vérification de la signature`
    Le processus de vérification de la signature numérique des messages est décrit dans le diagramme ci dessous :  
    <img src="./images/verification-signature.png" />

    ## Limitation des requêtes
    L’algorithme du seau à jeton __(Token Bucket Algorithm)__ est utilisé pour effectuer la limitation des requêtes par participant. C’est une technique utilisée pour la gestion de la bande passante et la régulation de la fréquence des requêtes.

    Le fonctionnement de l'algorithme est comme suit : un seau est rempli de jetons à une certaine vitesse (débit) et chaque requête nécessite l'utilisation d'un certain nombre de jetons. 
    Si le seau ne contient pas suffisamment de jetons pour une requête donnée, celle-ci est rejetée.
    Pour un plan d’usage configuré comme suit:  
    * __débit__: 3 requêtes par secondes: 
    * __burst__: 9 requêtes maximum

    Chaque seconde, 3 nouveaux jetons sont ajoutés au seau, jusqu'à la limite maximale de 9 jetons. Tant que le taux de demande ne dépasse pas le taux de recharge de jetons, tout va bien. Cependant, si le participant envoie 4 requêtes par seconde, le seau commencera à s'épuiser de 1 jeton par seconde. Après 6 secondes, tous les jetons dans le seau sont épuisés et l’API retourne une erreur __429: Too Many Requests__

  version: 0.0.1
  x-logo:
    url: "https://bceao.int/themes/medianet/image/png/logo_fr.png"

  contact:
    email: contact@pi.bceao.com
    url: "https:/pi.bceao.com"
  license:
    name: SPI 0.0.1
    url: "#"

servers:
  - url: https://api.test.pi-bceao.com/spi/v1

## the default validator applied to endpoints

# Define Endpoints
paths:
  /transferts:
    post:
      tags:
        - Transferts
      summary: Pour envoyer une demande de transfert de fonds
      description: Envoyer un pacs.008 au SPI pour effectuer un transfert de fonds
      operationId: envoyerTransfert
      requestBody:
        description: Message ISO 20022 pacs.008
        content:
          application/xml:
            schema:
              $ref: ./schemas/pacs.008.yml#/components/schemas/MessagePacs008
            examples:
              VIREMENT:
                $ref: ./exemples/pacs.008/virement.yml
              PAIEMENT:
                $ref: ./exemples/pacs.008/paiement.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/envoi-transfert.yml

  /transferts/rapports:
    post:
      tags:
        - Transferts
      summary: Pour envoyer la reponse d'une demande de transfert de fonds
      description: Envoyer un pacs.002 au SPI pour effectuer un transfert de fonds
      operationId: envoyerRapportTransfert
      requestBody:
        description: Message ISO 20022 pacs.002
        content:
          application/xml:
            schema:
              $ref: ./schemas/pacs.002.yml#/components/schemas/MessagePacs002
            examples:
              AVIS_DEBIT:
                $ref: ./exemples/pacs.002/avis_debit.yml
              AVIS_CREDIT:
                $ref: ./exemples/pacs.002/avis_credit.yml
              MODIF_CODE_SERVIVE:
                $ref: ./exemples/pacs.002/modif_code_service.yml
              REJET:
                $ref: ./exemples/pacs.002/rejet.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/reponse-transfert.yml

  /transferts/statuts:
    post:
      tags:
        - Transferts
      summary: Pour la recherche de statut d'une demande de virement
      description: Envoyer un pacs.028 au SPI pour effectuer la recherche de statut
      operationId: envoyerDemandeStatutTransfert
      requestBody:
        description: Message ISO 20022 pacs.028
        content:
          application/xml:
            schema:
              $ref: ./schemas/pacs.028.yml#/components/schemas/MessagePacs028
            examples:
              RECHERCHE_STATUT_VIREMENT:
                $ref: ./exemples/pacs.028/recherche_statut_virement.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/statut-transfert.yml

  /verifications-identites:
    post:
      tags:
        - Verifications-Identites
      summary: Pour envoyer une demande de verification d'identité
      description: Envoyer un acmt.023 au SPI pour effectuer la verification d'identité
      operationId: envoyerVerificationIdentite
      requestBody:
        description: Message ISO 20022 acmt.023
        content:
          application/xml:
            schema:
              $ref: ./schemas/acmt.023.yml#/components/schemas/MessageAcmt023
            examples:
              VERIFICATION_IDENTITE_TYPE_OTHER:
                $ref: ./exemples/acmt.023/type_other.yml
              VERIFICATION_IDENTITE_TYPE_IBAN:
                $ref: ./exemples/acmt.023/type_iban.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/envoi-verification-identite.yml

  /verifications-identites/rapports:
    post:
      tags:
        - Verifications-Identites
      summary: Pour envoyer la reponse d'une demande de verification d'identité
      description: Envoyer un acmt.024 au SPI pour repondre à une verification d'identité
      operationId: envoyerReponseVerificationIdentite
      requestBody:
        description: Message ISO 20022 acmt.024
        content:
          application/xml:
            schema:
              $ref: ./schemas/acmt.024.yml#/components/schemas/MessageAcmt024
            examples:
              REPONSE_VERIFICATION_IDENTITE_TYPE_OTHER:
                $ref: ./exemples/acmt.024/reponse_type_other.yml
              REPONSE_VERIFICATION_IDENTITE_TYPE_IBAN:
                $ref: ./exemples/acmt.024/reponse_type_iban.yml
              REJET_VERIFICATION_IDENTITE:
                $ref: ./exemples/acmt.024/rejet.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/reponse-verification-identite.yml

  /notifications:
    post:
      tags:
        - Notifications
      summary: Pour envoyer une notification au SPI ou à destinatination de SPI
      description: Envoyer un admi.004 au SPI pour effectuer un test de connectivité
      operationId: envoyerNotification
      requestBody:
        description: Message ISO 20022 admi.004
        content:
          application/xml:
            schema:
              $ref: ./schemas/admi.004.yml#/components/schemas/MessageAdmi004
            examples:
              MISE_À_JOUR_SPI:
                $ref: ./exemples/admi.004/mjpi.yml
              TEST_CONNECTIVITE:
                $ref: ./exemples/admi.004/ping.yml
              INFORMATION:
                $ref: ./exemples/admi.004/info.yml
              MESSAGE_LIBRE:
                $ref: ./exemples/admi.004/libre.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/envoi-test-connectivite.yml

  /notifications/accuses:
    post:
      tags:
        - Notifications
      summary: Pour envoyer la reponse d'un test de connectivité
      description: Envoyer un admi.011 au SPI pour repondre à un test de connectivité
      operationId: envoyerRapportTest
      requestBody:
        description: Message ISO 20022 admi.011
        content:
          application/xml:
            schema:
              $ref: ./schemas/admi.011.yml#/components/schemas/MessageAdmi011
            examples:
              REPONSE:
                $ref: ./exemples/admi.011/resultat.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/reponse-test-connectivite.yml

  /relations/creations:
    post:
      tags:
        - Relations
      summary: Pour envoyer une demande de sponsorisation
      description: Envoyer un reda.014 au SPI pour initier un processus de sponsorisation
      operationId: envoyerDemandeSponsorisation
      requestBody:
        description: Message ISO 20022 reda.014
        content:
          application/xml:
            schema:
              $ref: ./schemas/reda.014.yml#/components/schemas/MessageReda014
            examples:
              DEMANDE_PARTICIPANT_DIRECT:
                $ref: ./exemples/reda.014/direct.yml
              DEMANDE_PARTICIPANT_INDIRECT:
                $ref: ./exemples/reda.014/indirect.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/demande-sponsorisation.yml

  /relations/ruptures:
    post:
      tags:
        - Relations
      summary: Pour envoyer une demande de rupture de sponsorisation
      description: Envoyer un reda.031 au SPI pour initier un processus de rupture de sponsorisation
      operationId: envoyerDemandeRupture
      requestBody:
        description: Message ISO 20022 reda.031
        content:
          application/xml:
            schema:
              $ref: ./schemas/reda.031.yml#/components/schemas/MessageReda031
            examples:
              RUPTURE:
                $ref: ./exemples/reda.031/rupture.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/rupture-sponsorisation.yml

  /participants/modifications:
    post:
      tags:
        - Relations
      summary: Pour envoyer une demande de modification d'informations
      description: Envoyer un reda.022 au SPI pour demander la modification de données
      operationId: envoyerDemandeModification
      requestBody:
        description: Message ISO 20022 reda.022
        content:
          application/xml:
            schema:
              $ref: ./schemas/reda.022.yml#/components/schemas/MessageReda022
            examples:
              AJOUT_CONTACT:
                $ref: ./exemples/reda.022/ajout-contact.yml
              CHANGEMENT_NOM:
                $ref: ./exemples/reda.022/changement-nom.yml
              CHANGEMENT_ADRESSE:
                $ref: ./exemples/reda.022/changement-adresse.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/demande-modification-donnees.yml

  /participants/liste:
    post:
      tags:
        - Liste-Participants
      summary: Pour envoyer une demande de la liste des participants
      description: Envoyer un camt.013 au SPI pour demander la liste des participants
      operationId: envoyerDemandeListeParticipants
      requestBody:
        description: Message ISO 20022 camt.013
        content:
          application/xml:
            schema:
              $ref: ./schemas/camt.013.yml#/components/schemas/MessageCamt013
            examples:
              AJOUT_CONTACT:
                $ref: ./exemples/camt.013/demande-liste.yml
        required: true
      responses:
        "201":
          $ref: "#/components/responses/FormatCorrect"
        "400":
          $ref: "#/components/responses/FormatInvalide"
        "401":
          $ref: "#/components/responses/AutorisationsManquantes"
        "500":
          $ref: "#/components/responses/ProblemeServeur"
      security:
        - api_key: []
          mutual_tls: []
      x-codeSamples:
        $ref: ./codes/demande-liste-participants.yml
  

components:
  # *********** SECURITY
  securitySchemes:
    api_key:
      type: apiKey
      name: x-api-key
      in: header
      description: Utilisation de API Key pour contrôler l'accès aux ressources et aux fonctionnalités de SPI en spécifiant un identifiant unique et secret dans les requêtes.
    mutual_tls:
      type: mutualTLS
      description: Utilisation d'une connexion sécurisée bidirectionnelle pour l'authentification des clients et le serveur.

  # *********** SCHEMAS
  schemas:

    # Problem RFC 7807
    Problem7807:
      type: object
      properties:
        type:
          type: string
          description: Référence URI qui identifie le type de problème
          example: about:blank
        title:
          type: string
          description: Un bref résumé du problème
          example: Bad Request
        status:
          type: integer
          description: Le code d'état HTTP pour cette occurrence du problème
          example: 400
        detail:
          type: string
          description: Explication spécifique à cette occurrence du problème
          example: "122:0 Element '{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.10}Id': [facet 'maxLength'] The value has a length of '36'; this exceeds the allowed maximum length of '34'."
      xml:
        name: problem
        namespace: "urn:ietf:rfc:7807"

    Succes:
      type: object
      properties:
        Location:
          type: string
          description: Identifiant de la ressource créée
          example: 5gkifc94-fe35-45c0-abab-8459de615117
        Date:
          type: string
          description: Date de réception du message
          example: Wed, 17 Feb 2023 10:30:00 GMT
          

  # *********** RESPONSES
  responses:
    FormatInvalide:
      description: La requête est malformée
      content:
        application/problem+xml:
          schema:
            $ref: "#/components/schemas/Problem7807"
          examples:
            example:
              $ref: "#/components/examples/Problem7807ExempleBadRequestXML"
        application/problem+json:
          schema:
            $ref: "#/components/schemas/Problem7807"
          examples:
            exemple:
              $ref: "#/components/examples/Problem7807ExempleBadRequestJSON"

    AutorisationsManquantes:
      description: Autorisations manquantes
      content:
        application/problem+xml:
          schema:
            $ref: "#/components/schemas/Problem7807"
          examples:
            example:
              $ref: "#/components/examples/Problem7807ExempleUnauthorizedXML"
        application/problem+json:
          schema:
            $ref: "#/components/schemas/Problem7807"
          examples:
            exemple:
              $ref: "#/components/examples/Problem7807ExempleUnauthorizedJSON"

    ProblemeServeur:
      description: Erreur inattendue
      content:
        application/problem+xml:
          schema:
            $ref: "#/components/schemas/Problem7807"
          examples:
            example:
              $ref: "#/components/examples/Problem7807ExempleInternalServerErrorXML"
        application/problem+json:
          schema:
            $ref: "#/components/schemas/Problem7807"
          examples:
            exemple:
              $ref: "#/components/examples/Problem7807ExempleInternalServerErrorJSON"

    FormatCorrect:
      description: Message créé.
      content:
        application/xml:
          schema:
            $ref: "#/components/schemas/Succes"
          examples:
            example:
              $ref: "#/components/examples/ExempleCreatedXML"

  # *********** EXEMPLES
  examples:
    # Probleme 7807
    Problem7807ExempleBadRequestJSON:
      summary: "Problème format invalide"
      value:
        type: "about:blank"
        title: "Bad Request"
        status: 400
        detail: "Format du message invalide"

    Problem7807ExempleBadRequestXML:
      summary: "Problème format invalide"
      value: |
        <problem xmlns="urn:ietf:rfc:7807">
          <type>about:blank</type>
          <title>Bad Request</title>
          <status>400</status>
          <detail>Format du message invalide</detail>
        </problem>

    Problem7807ExempleUnauthorizedJSON:
      summary: "Problème format invalide"
      value:
        type: "about:blank"
        title: "Unauthorized"
        status: 401
        detail: "Autorisations insuffisantes"

    Problem7807ExempleUnauthorizedXML:
      summary: "Problème format invalide"
      value: |
        <problem xmlns="urn:ietf:rfc:7807">
          <type>about:blank</type>
          <title>Unauthorized</title>
          <status>401</status>
          <detail>Autorisations insuffisantes</detail>
        </problem>

    Problem7807ExempleInternalServerErrorJSON:
      summary: "Problème format invalide"
      value:
        type: "about:blank"
        title: "Internal Server Error"
        status: 500
        detail: "Une erreur inattendue a empêché le serveur de traiter la requête."

    Problem7807ExempleInternalServerErrorXML:
      summary: "Problème format invalide"
      value: |
        <problem xmlns="urn:ietf:rfc:7807">
          <type>about:blank</type>
          <title>Internal Server Error</title>
          <status>500</status>
          <detail>Une erreur inattendue a empêché le serveur de traiter la requête.</detail>
        </problem>

    ExempleCreatedXML:
      summary: "Problème format invalide"
      value: |
        HTTP/1.1   201   Created

        Keep-Alive: timeout=60
        Date: Wed, 21 Feb 2023 15:30:00 GMT
        Location: d1affc94-2e35-44c0-abab-2149de615116

